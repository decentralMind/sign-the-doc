pragma solidity ^0.5.0;

/**
* @dev Deploy Hash of the document/file  and let anyone or only authorized signers
* to sign the hash of the deployed document thus completing document signature process.
*/
contract SignTheDoc {

  // Document data.
  struct Creator {
    address creatorAddress;
    uint256 creationDate;
    uint256 expiryDate;
    bytes32 docHash;
    bytes signature;
    address[] authorisedSignerList;
    address[] whoSigned;
    mapping(address => bool) authorisedToSign;
    mapping(address => Signer) signerInfo;
    mapping(address => bool) signedOrNot;
  }

  // Signer Data.
  struct Signer {
    address signerAddress;
    uint256 signedDate;
    bytes32 docHash;
    bytes signature;
  }

  // Hash of the data is linked to Creator Struct.
  mapping(bytes32 => Creator) docData;

  /**
   * @dev Modifier to check if document already deployed.
   */
  modifier isDocHashUnique(bytes32 docHash) {
    require(
      docData[docHash].docHash == bytes32(0),
      'Hash must be unique.'
    );
    _;
  }

  /**
   * @dev Modifier to check if supplied date already expired.
   */
  modifier isExpired(uint256 expiryDate) {
    require(
      expiryDate > block.timestamp || expiryDate == 0,
      'Contract expiry date should be greater than current time.');
    _;
  }

  /**
   * @dev Modifier to check if the signature is valid.
   */
  modifier verifySignature(bytes32 hash, bytes32 r, bytes32 s, uint8 v) {
    bytes memory prefix = "\x19Ethereum Signed Message:\n32";
    bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));
    require(ecrecover(prefixedHash, v, r, s) == msg.sender,
      'Signature verification failed');
    _;
  }

  /**
   * @dev Checks following multiple validations:-
   * - Checks if supplied document hash `signerDocHash` is correct and already deployed.
   * - Checks if document `creator` address is correct with provided one.
   * - Checks if document expiry date is valid. Throws if expiry date is less than current time.
   * - Checks if sender has already signed the document. Throws if already signed.
   * - Checks if sender has been added to authorised list. Throw if not authorised to sign.
   *
   * Returns true if all validation passed.
   */
  function _multipleValidations(address creator, bytes32 signerDocHash) private view returns(bool) {
    Creator memory doc = docData[signerDocHash];

    // Checks if supplied document hash is correct and already deployed.
    require(
      signerDocHash == doc.docHash,
      'Failed to verify document hash.'
    );

    // Checks if document creator address is correct with provided one.
    require(
      doc.creatorAddress == creator,
      'Failed to verify creator address.'
    );

    // Checks if document expiry date is valid. Throws if expiry date is less than current time.
    require(
      (doc.expiryDate > block.timestamp) || (doc.expiryDate == 0),
      'Date already expired. Signing is disallowed now.'
    );

    // Checks if sender has already signed the document. Throws if already signed.
    require(
      !(docData[signerDocHash].signedOrNot[msg.sender]),
      'Already signed by this account. Multiple signing is not allowed.'
    );

    // Checks if sender has been added to authorised list. Throw if not authorised to sign.
    if (doc.authorisedSignerList.length != 0) {
      require(
        isAuthorised(signerDocHash),
        'Provided address not authorised to sign the document.'
      );
    }

    return true;
  }

  /**
   * @dev Opens document for signing process by providing document hash `docHash`,
   * `signature`, `authorisedSignerList` and valid ECDSA `signature` and it's data `r`, `s`
   * and `v`.
   * `_recordInitialDoc` method is called for final recording entry.
   * Requirements:-
   * - Generated document hash `docHash` must be unique.
   * - Must provide valid `expiryDate`.
   * - Provide ECDSA `signature` with data `r`, `s` and `v`, generated by signing document hash `docHash`
   *   must be valid.
   */
  function createDocToSign(
    uint256 expiryDate,
    bytes memory signature,
    address[] memory authorisedSignerList,
    bytes32 docHash,
    bytes32 r,
    bytes32 s,
    uint8 v
  )
  public
  isDocHashUnique(docHash)
  isExpired(expiryDate)
  verifySignature(docHash, r, s, v) {
    require(_recordInitialDoc(expiryDate, signature, authorisedSignerList, docHash),
      'Document creation process failed. Check if the provided data is valid.');
  }

  /**
   * @dev Records new document for signing process. Data are passed through
   * `createDocToSign` method.
   * Check `createDocToSign` method for parameters description.
   * Returns true.
   */
  function _recordInitialDoc(
    uint256 expiryDate,
    bytes memory signature,
    address[] memory authorisedSignerList,
    bytes32 docHash
  )
  private returns (bool) {
    Creator storage creator = docData[docHash];

    creator.creatorAddress = msg.sender;
    creator.creationDate = block.timestamp;
    creator.expiryDate = expiryDate;
    creator.docHash = docHash;
    creator.signature = signature;
    creator.authorisedSignerList = authorisedSignerList;

    if (authorisedSignerList.length == 1) {
      creator.authorisedToSign[authorisedSignerList[0]] = true;
    } else if (authorisedSignerList.length > 1) {
      for (uint i = 0; i < authorisedSignerList.length; i++) {
        creator.authorisedToSign[authorisedSignerList[i]] = true;
      }
    }

    return true;
  }

  /**
   * @dev Returns `creatorAddress`, `creationDate`, `expiryDate`, document hash `docHash`,
   * valid `signature`, `authorisedSigners` list and `whoSigned` the document already of the
   * provided registered hash of the document `regDocHash`.
   */
  function getDocData(bytes32 regDocHash)
  external
  view
  returns (
    address creatorAddress,
    uint256 creationDate,
    uint256 expiryDate,
    bytes32 docHash,
    bytes memory signature,
    address[] memory authorisedSigners,
    address[] memory whoSigned
  ) {
    Creator memory cr = docData[regDocHash];
    return (cr.creatorAddress, cr.creationDate, cr.expiryDate, cr.docHash, cr.signature, cr.authorisedSignerList, cr.whoSigned);
  }

  /**
   * @dev Signer signs the hash `signerDocHash` of the document deployed by the `creator` address.
   * Signer must provide valid ECDSA `signature` with it's data `r`, `s` and v.
   * Signing the document and recording process is completed through `_publishSign` method.
   * Requirements:-
   * - Checks if supplied document hash `signerDocHash` is correct and already deployed.
   * - Checks if document `creator` address is correct.
   * - Checks if document `expiryDate` is valid.
   * - Checks if signer has already signed the document.
   * - Checks if signer has authority to sign the document.
   */
  function signTheDoc(address creator, bytes32 signerDocHash, bytes32 r, bytes32 s, uint8 v, bytes memory signature) public {
    require(_multipleValidations(creator, signerDocHash));
    require(_publishSign(signerDocHash, r, s, v, signature));
  }

  /**
   * @dev Completes the signing process of given registered document hash `signerDocHash`, signer
   * must provide valid EDSCA `signature` with it's data `r`, `s` and `v`.
   * Requirements: -
   * - Signer EDSCA `signature` with it's data `r`, `s` and `v` should be valid.
   *
   * Returns true.
   */
  function _publishSign(bytes32 signerDocHash, bytes32 r, bytes32 s, uint8 v, bytes memory signature)
  private
  verifySignature(signerDocHash, r, s, v)
  returns (bool) {
    Creator storage doc = docData[signerDocHash];
    Signer memory signer = Signer(msg.sender, block.timestamp, signerDocHash, signature);
    doc.signerInfo[msg.sender] = signer;
    doc.whoSigned.push(msg.sender);
    doc.signedOrNot[msg.sender] = true;
    return true;
  }

  /**
   * @dev Returns true if sender is allowed to sign the document.
   */
  function isAuthorised(bytes32 docHash) public view returns (bool) {
    return (docData[docHash].authorisedToSign[msg.sender]);
  }

  /**
  * @dev Check if deployed document hash `docHash` is already signed by `signer`.
  * Return true if signed and vice-versa.
  */
  function isSigned(bytes32 docHash, address signer) external view returns (bool signed) {
    return docData[docHash].signedOrNot[signer];
  }

  /**
  * @dev Returns 'signerAddress', `signedDate`, deployed document hash `docHash`,
  * `signature` and if the document is `signedOrNot` by the `signer` for the registered
  * document save as hash format `signerDocHash`.
  */
  function getSignerInfo(bytes32 signerDocHash, address signer)
  external
  view
  returns (
    address signerAddress,
    uint256 signedDate,
    bytes32 docHash,
    bytes memory signature,
    bool signedOrNot) {

    Signer memory si = docData[signerDocHash].signerInfo[signer];
    bool signed = docData[signerDocHash].signedOrNot[signer];
    return (si.signerAddress, si.signedDate, si.docHash, si.signature, signed);
  }
}
